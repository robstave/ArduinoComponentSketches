/**
   ACS-85-0032
   ATTiny85  Clocked LFO
   LFO that uses a clock signal to set the tempo.

   Despite the simple approach, it works pretty ok.
   Its not well debounced ( none really), so consider a LPF
   on that pin. ( 1kohm/100nf or whatever)

   Basically, I have a counter that acts like millis(), but instead of 
   millis, I generally utilize both timer 0 and 1 and just add a counter
   to one of em.  Its not milliseconds, but its usually linear and workable.  
   
   Each Clock trigger will reset the wavetable index and find the
   delta which is used to calculate the time until the next wavetable index.

   There are 7 waveforms

   Ramp up
   Ramp Down
   Triangle
   Sine
   Square
   Random ( 4 notes per)
   Steps ( random alt with 0)

   There is also a mod that speeds things up


   Rob Stave (Rob the fiddler) ccby 2023
*/

//  ATTiny overview
//                           +-\/-+
//                    Reset 1|    |8  VCC
//   (pin4) mode   A3   PB3 2|    |7  PB2 (pin2) clock
//   (pin4) cv mod A2   PB4 3|    |6  PB1 (pin1) PWM LFO out
//                      GND 4|    |5  PB0 (pin0) trigger Square out
//                           ------

 

#ifndef cbi
#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#endif
#ifndef sbi
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
#endif

const uint8_t triangleTable[] PROGMEM = {
  0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10,
  0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20,
  0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30,
  0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40,
  0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50,
  0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60,
  0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70,
  0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80,
  0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90,
  0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0,
  0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0,
  0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0,
  0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0,
  0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0,
  0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0,
  0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0xff,
  0xfe, 0xfc, 0xfa, 0xf8, 0xf6, 0xf4, 0xf2, 0xf0,
  0xee, 0xec, 0xea, 0xe8, 0xe6, 0xe4, 0xe2, 0xe0,
  0xde, 0xdc, 0xda, 0xd8, 0xd6, 0xd4, 0xd2, 0xd0,
  0xce, 0xcc, 0xca, 0xc8, 0xc6, 0xc4, 0xc2, 0xc0,
  0xbe, 0xbc, 0xba, 0xb8, 0xb6, 0xb4, 0xb2, 0xb0,
  0xae, 0xac, 0xaa, 0xa8, 0xa6, 0xa4, 0xa2, 0xa0,
  0x9e, 0x9c, 0x9a, 0x98, 0x96, 0x94, 0x92, 0x90,
  0x8e, 0x8c, 0x8a, 0x88, 0x86, 0x84, 0x82, 0x80,
  0x7e, 0x7c, 0x7a, 0x78, 0x76, 0x74, 0x72, 0x70,
  0x6e, 0x6c, 0x6a, 0x68, 0x66, 0x64, 0x62, 0x60,
  0x5e, 0x5c, 0x5a, 0x58, 0x56, 0x54, 0x52, 0x50,
  0x4e, 0x4c, 0x4a, 0x48, 0x46, 0x44, 0x42, 0x40,
  0x3e, 0x3c, 0x3a, 0x38, 0x36, 0x34, 0x32, 0x30,
  0x2e, 0x2c, 0x2a, 0x28, 0x26, 0x24, 0x22, 0x20,
  0x1e, 0x1c, 0x1a, 0x18, 0x16, 0x14, 0x12, 0x10,
  0xe, 0xc, 0xa, 0x8, 0x6, 0x4, 0x2, 0x0
};

const uint8_t sineTable[] PROGMEM = {

  0x0, 0x0, 0x0, 0x01, 0x01, 0x01, 0x02, 0x02,
  0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
  0x0b, 0x0c, 0x0d, 0x0f, 0x10, 0x12, 0x14, 0x15,
  0x17, 0x19, 0x1b, 0x1d, 0x1f, 0x21, 0x23, 0x25,
  0x27, 0x2a, 0x2c, 0x2e, 0x31, 0x33, 0x36, 0x38,
  0x3b, 0x3e, 0x40, 0x43, 0x46, 0x49, 0x4c, 0x4f,
  0x51, 0x54, 0x57, 0x5a, 0x5d, 0x60, 0x63, 0x67,
  0x6a, 0x6d, 0x70, 0x73, 0x76, 0x79, 0x7c, 0x80,
  0x80, 0x83, 0x86, 0x89, 0x8c, 0x8f, 0x92, 0x95,
  0x98, 0x9c, 0x9f, 0xa2, 0xa5, 0xa8, 0xab, 0xae,
  0xb0, 0xb3, 0xb6, 0xb9, 0xbc, 0xbf, 0xc1, 0xc4,
  0xc7, 0xc9, 0xcc, 0xce, 0xd1, 0xd3, 0xd5, 0xd8,
  0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8,
  0xea, 0xeb, 0xed, 0xef, 0xf0, 0xf2, 0xf3, 0xf4,
  0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfb, 0xfc,
  0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfd, 0xfd,
  0xfc, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6,
  0xf5, 0xf4, 0xf2, 0xf1, 0xef, 0xee, 0xec, 0xeb,
  0xe9, 0xe7, 0xe5, 0xe3, 0xe1, 0xdf, 0xdd, 0xdb,
  0xd9, 0xd7, 0xd4, 0xd2, 0xcf, 0xcd, 0xca, 0xc8,
  0xc5, 0xc3, 0xc0, 0xbd, 0xba, 0xb8, 0xb5, 0xb2,
  0xaf, 0xac, 0xa9, 0xa6, 0xa3, 0xa0, 0x9d, 0x9a,
  0x97, 0x94, 0x91, 0x8e, 0x8a, 0x87, 0x84, 0x81,
  0x7e, 0x7b, 0x78, 0x75, 0x71, 0x6e, 0x6b, 0x68,
  0x65, 0x62, 0x5f, 0x5c, 0x59, 0x56, 0x53, 0x50,
  0x4d, 0x4a, 0x47, 0x45, 0x42, 0x3f, 0x3c, 0x3a,
  0x37, 0x35, 0x32, 0x30, 0x2d, 0x2b, 0x28, 0x26,
  0x24, 0x22, 0x20, 0x1e, 0x1c, 0x1a, 0x18, 0x16,
  0x14, 0x13, 0x11, 0x10, 0x0e, 0x0d, 0x0b, 0x0a,
  0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x03,
  0x02, 0x02, 0x01, 0x01, 0x0, 0x0, 0x0, 0x0
};


const int clockInt = 0;  // digital pin 2 is now interrupt 0
volatile unsigned int lfsr = 1;

volatile unsigned long counter = 0;
volatile bool triggerDetected = false;

// the setup function runs once when you press reset or power the board
void setup() {

  DDRB = B00000011;  //set output bits
  noInterrupts();    // disable all interrupts
  attachInterrupt(clockInt, clockCounter, RISING);

  // Enable 64 MHz PLL and use as source for Timer1
  PLLCSR = 1 << PCKE | 1 << PLLE;

  // Set up Timer/Counter1 for PWM output
  TIMSK = 0;                                     // Timer interrupts OFF
  TCCR1 = 1 << PWM1A | 2 << COM1A0 | 1 << CS10;  // PWM A, clear on match, 1:1 prescale
  //GTCCR = 1<<PWM1B | 2<<COM1B0;           // PWM B, clear on match
  OCR1A = 0;  //OCR1B = 128;

  pinMode(0, OUTPUT);
  pinMode(1, OUTPUT);  // Enable PWM output pin
  pinMode(2, INPUT);

  //Set up Timer/Counter0 for 20kHz interrupt to output samples.

  TCCR0A = 3 << WGM00;              // Fast PWM
  TCCR0B = 1 << WGM02 | 2 << CS00;  // 1/8 prescale
  TIMSK = 1 << OCIE0A;              // Enable compare match, disable overflow
  OCR0A = 49;                       // Divide by 400

  // Enable PWM output pin
  interrupts();  // enable all interrupts
}

void clockCounter()  // called by interrupt
{
  triggerDetected = true;
}

//  Normally, this is my DDS code and such.  Sometimes Millis can be a bear to use as its really is tied to Timer 0 or 1...I never
// remember.  Instead, you can create your own millis or whatever with just a counter.  You can even piggy back that counter
// in regular interrupt code.
ISR(TIMER0_COMPA_vect) {
  counter = counter + 1;
}


// LFSR for pseudorandom numbers
void clockLfsr() {

  //calculate new state
  boolean outputBit = bitRead(lfsr, 10) ^ bitRead(lfsr, 12)
                      ^ bitRead(lfsr, 13) ^ bitRead(lfsr, 15);
  lfsr = lfsr << 1;
  lfsr |= outputBit;
}

/**
   Set the OCR1A value to the indexed value in the wavetable ( or math equiv)
*/
void setPWMValue(byte index, byte selLFO) {

  // Ramp up. Its just a counter
  if (selLFO == 0) {
    OCR1A = index;
    return;
  }

  // Ramp Down
  if (selLFO == 1) {
    OCR1A = 255 - index;
    return;
  }

  // Triangle
  if (selLFO == 2) {
    OCR1A = (pgm_read_byte_near(triangleTable + index));
    return;
  }

  // Sine...its not too different
  if (selLFO == 3) {
    OCR1A = (pgm_read_byte_near(sineTable + index));
    return;
  }


  // more of a 25% pulse.  If you want a shorter pulse...go for something like 10 instead of 64
  if (selLFO == 4) {
    if (index > 64) {
      OCR1A = 0;
    } else {
      OCR1A = 255;
    }
    return;
  }



  //  random.  Just bottom byte of lfsr
  if (selLFO == 5) {

    if (index == 0 || index == 64 || index == 128 || index == 192)
      OCR1A = lfsr & B11111111;
    return;
  }

  //  random steps
  // Think:  0 33 0 230 0 111 0 44

  if (selLFO > 5) {

    if (index == 0 || index == 64 || index == 128 || index == 192)
      OCR1A = lfsr & B11111111;
    if (index == 32 || index == 96 || index == 160 || index == 224)
      OCR1A = 0;
    return;
  }
}



void loop() {

  long lastCount = 0;
  long thisCount = 0;
  unsigned int delta = 0;
  unsigned int step = 0;
  long nextCount = 100000000;  //  initial state is none

  uint16_t mod = 0;
  uint8_t selLFO = 0;
  uint8_t MUX = 2;

  byte index = 0;

  byte triggerLen = 32;
  boolean triggerPinTrue = false;

  sbi(ADCSRA, ADSC);  //start next convert

  while (true) {

    if (triggerDetected == true) {

      digitalWrite(0, HIGH);  // Clock Trigger
      triggerPinTrue = true;
      
      triggerDetected = false;
      lastCount = thisCount;
      thisCount = counter;
      delta = thisCount - lastCount;
      index = 0;
      step = delta / 256;
      nextCount = thisCount + step;
    }

    if (nextCount % 15 == 0) {
      // sprinkle some random...optional
      clockLfsr();
    }

    // increment wavetable when time elapses
    if (counter > nextCount) {

      index++;  // increment wavetable pointer

      // EAch clock cycle gets 255 mini steps.
      // The trigger is a proportion of that based
      // on the value of triggerLen
      if (triggerPinTrue && (index > triggerLen)) {
        digitalWrite(0, LOW);  // set trigger to zero
        triggerPinTrue = false;
      }

      nextCount = counter + step;

      setPWMValue(index, selLFO);
      clockLfsr();  // add some random

      // cv mod adds multiples.  and they accumulate.
      // so the index will 2x, 3x or 4x.  Experiment
      // If you wanted to make it go slower, you could 
      // have an inhibit flag or something
      if (mod > 255) {
        index++;
      }

      if (mod > 512) {
        index++;
      }

      if (mod > 768) {
        index++;
      }
    }

    // read pots  This just alternates between A2 and A3
    if (!(ADCSRA & 64)) {
      if (MUX == 2) {
        mod = ((ADCL + (ADCH << 8)));
      }
      if (MUX == 3) {
        int x = ((ADCL + (ADCH << 8)));
        selLFO = map(x, 0, 1023, 0, 7);
      }
      MUX++;
      if (MUX == 4) MUX = 2;
      ADMUX = MUX;        //Select MUX
      sbi(ADCSRA, ADSC);  //start next conversation
    }
  }
}